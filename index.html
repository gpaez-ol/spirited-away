<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			html, body {
			height: 100%;
			margin: 0;
			}
			#c {
			width: 100%;
			height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas id="c"></canvas>
		<!-- <script src="js/three.js"></script>
		<script src="js/orbitControls.js"></script> --> -->
		<script type="module">
		import * as THREE from './js/three.module.js';
		import  {OrbitControls} from './js/orbitControls.js';

		var PrismGeometry = function(a, b, c, h) {
			var vs = [a,b,c];
			var shape = new THREE.Shape();
			( function f(ctx) {
				ctx.moveTo(vs[0].x, vs[0].y);

				for (var i = 1; i < vs.length; i++) {
					ctx.lineTo(vs[i].x, vs[i].y);
				}
				ctx.lineTo(vs[0].x, vs[0].y);
			}) (shape);

			var settings = {};
			settings.bevelEnabled = false;
			settings.amount = h;
			return new THREE.ExtrudeGeometry(shape, settings);
		};

		function main() {
		const canvas = document.querySelector('#c');
		const renderer = new THREE.WebGLRenderer({canvas});

		const fov = 75;
		const aspect = 2;  // the canvas default
		const near = 0.1;
		const far = 1000;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.z = 100;

		const controls = new OrbitControls(camera, canvas);
		controls.target.set(0, 0, 0);
		controls.update();

		const scene = new THREE.Scene();

		{
			const color = 0xFFFFFF;
			const intensity = 1;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-1, 2, 4);
			scene.add(light);
		}

		const boxWidth = 100;
		const boxHeight = 25;
		const boxDepth = 25;
		const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

		var A = new THREE.Vector2(0, 0);
		var B = new THREE.Vector2(30, 10);
		var C = new THREE.Vector2(20, 32);
		var height = 25;                   
		var endpointGeometry = new PrismGeometry(A, B, C, height); 

		function makeInstance(geometry, color, x, y=0, z=0, rx=0, rz=0) {
			const material = new THREE.MeshPhongMaterial({color});

			const instance = new THREE.Mesh(geometry, material);
			scene.add(instance);

			instance.position.x = x;
			instance.position.y = y;
			instance.position.z = z;
			instance.rotation.x = rx;
			instance.rotation.z = rz;

			return instance;
		}

		const wagons = [
			makeInstance(geometry, 0x44aa88,  -55),
			makeInstance(geometry, 0x8844aa, 55),
			makeInstance(endpointGeometry, 0x44aa88, -136, -10, -12, 0, - Math.PI / 4 * .5),
			makeInstance(endpointGeometry, 0x8844aa, 136, -10, 12, Math.PI, Math.PI - Math.PI / 4 * .5),
		];

		{
			const loader = new THREE.TextureLoader();
			const texture = loader.load(
			'images/threeskybox.jpeg',
			() => {
				const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
				rt.fromEquirectangularTexture(renderer, texture);
				scene.background = rt.texture;
			});
		}

		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
			renderer.setSize(width, height, false);
			}
			return needResize;
		}

		function render(time) {
			time *= 0.001;

			if (resizeRendererToDisplaySize(renderer)) {
			const canvas = renderer.domElement;
			camera.aspect = canvas.clientWidth / canvas.clientHeight;
			camera.updateProjectionMatrix();
			}

			// wagons.forEach((cube, ndx) => {
			// const speed = 1 + ndx * .1;
			// const rot = time * speed;
			// cube.rotation.x = rot;
			// cube.rotation.y = rot;
			// });

			renderer.render(scene, camera);

			requestAnimationFrame(render);
		}

		requestAnimationFrame(render);
		}

		main();

		</script>
	</body>
</html>