<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Spirited Away</title>
		<style>
			html, body {
			height: 100%;
			margin: 0;
			}
			#c {
			width: 100%;
			height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas id="c"></canvas>
		<script type="module">
		import * as THREE from './js/three.module.js';
		import  {OrbitControls} from './js/orbitControls.js';
		var PrismGeometry = function(a, b, c, h) {
			var vs = [a,b,c];
			var shape = new THREE.Shape();
			( function f(ctx) {
				ctx.moveTo(vs[0].x, vs[0].y);

				for (var i = 1; i < vs.length; i++) {
					ctx.lineTo(vs[i].x, vs[i].y);
				}
				ctx.lineTo(vs[0].x, vs[0].y);
			}) (shape);
			var settings = {};
			settings.bevelEnabled = false;
			settings.amount = h;
			return new THREE.ExtrudeGeometry(shape, settings);
		};

		function main() {
		const canvas = document.querySelector('#c');
		const renderer = new THREE.WebGLRenderer({canvas});

		const fov = 75;
		const aspect = 2;  // the canvas default
		const near = 0.1;
		const far = 1000;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.z = 100;

		const controls = new OrbitControls(camera, canvas);
		controls.target.set(0, 0, 0);
		controls.update();

		const scene = new THREE.Scene();

		{
			const color = 0xFFFFFF;
			const intensity = 1;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-1, 2, 4);
			scene.add(light);
		}

		const mainBoxWidth = 50;
		const mainBoxHeight = 10;
		const mainBoxDepth = 25;
		const mainBoxGeometry = new THREE.BoxGeometry(mainBoxWidth, mainBoxHeight, mainBoxDepth);
		const mainBoxTexture = new THREE.TextureLoader().load( 'images/yellow-seamless-metal.jpg' ); 
		const mainBoxMaterial = new THREE.MeshBasicMaterial( { map: mainBoxTexture } );

		const rightMainBoxWidth = 25;
		const rightMainBoxHeight = 3;
		const rightMainBoxDepth = 25;
		const rightMainBoxGeometry = new THREE.BoxGeometry(rightMainBoxWidth, rightMainBoxHeight, rightMainBoxDepth);
		const rightMainBoxTexture = new THREE.TextureLoader().load( 'images/yellow-seamless-metal.jpg' ); 
		const rightMainBoxMaterial = new THREE.MeshBasicMaterial( { map: rightMainBoxTexture } );

		const leftMainBoxWidth = 25;
		const leftMainBoxHeight = 3;
		const leftMainBoxDepth = 25;
		const leftMainBoxGeometry = new THREE.BoxGeometry(leftMainBoxWidth, leftMainBoxHeight, leftMainBoxDepth);
		const leftMainBoxTexture = new THREE.TextureLoader().load( 'images/yellow-seamless-metal.jpg' ); 
		const leftMainBoxMaterial = new THREE.MeshBasicMaterial( { map: leftMainBoxTexture } );

		const lowerBoxWidth = 100;
		const lowerBoxHeight = 7.5;
		const lowerBoxDepth = 25;
		const lowerBoxGeometry = new THREE.BoxGeometry(lowerBoxWidth, lowerBoxHeight, lowerBoxDepth);
		const lowerBoxTexture = new THREE.TextureLoader().load( 'images/red-seamless-metal.jpg' ); 
		const lowerBoxMaterial = new THREE.MeshBasicMaterial( { map: lowerBoxTexture } );

		const upperBoxWidth = 100;
		const upperBoxHeight = 4;
		const upperBoxDepth = 25;
		const upperBoxGeometry = new THREE.BoxGeometry(upperBoxWidth, upperBoxHeight, upperBoxDepth);
		const upperBoxTexture = new THREE.TextureLoader().load( 'images/red-seamless-metal.jpg' ); 
		const upperBoxMaterial = new THREE.MeshBasicMaterial( { map: upperBoxTexture } );

		const linkBoxWidth = 12;
		const linkBoxHeight = 2;
		const linkBoxDepth = 25;
		const linkBoxGeometry = new THREE.BoxGeometry(linkBoxWidth, linkBoxHeight, linkBoxDepth);
		const linkBoxTexture = new THREE.TextureLoader().load( 'images/seamless-metal.jpg' ); 
		const linkBoxMaterial = new THREE.MeshBasicMaterial( { map: linkBoxTexture } );

		var A = new THREE.Vector2(0, 0);
		var B = new THREE.Vector2(30, 10);
		var C = new THREE.Vector2(20, 32);
		var height = 25;                   
		var endpointGeometry = new PrismGeometry(A, B, C, height); 

		function makeInstance(geometry,x, y=0, z=0, rx=0, rz=0,material=mainBoxMaterial) {
			const instance = new THREE.Mesh(geometry, material);
			scene.add(instance);
			instance.position.x = x;
			instance.position.y = y;
			instance.position.z = z;
			instance.rotation.x = rx;
			instance.rotation.z = rz;
			instance.material = material;
			return instance;
		}

		const wagons = [
			//left train box
			makeInstance(leftMainBoxGeometry,-92,-4),
			makeInstance(leftMainBoxGeometry,-92,4),
			makeInstance(mainBoxGeometry,-55),
			makeInstance(rightMainBoxGeometry,-18,-4), // lower
			makeInstance(rightMainBoxGeometry,-18,4), // upper
			makeInstance(lowerBoxGeometry,-55,-8.5,0,0,0,lowerBoxMaterial),
			makeInstance(upperBoxGeometry,-55,7,0,0,0,upperBoxMaterial),

			makeInstance(linkBoxGeometry,0,-6,0,0,0,linkBoxMaterial), // chain-link


			//right train box
			makeInstance(leftMainBoxGeometry,18,-4),
			makeInstance(leftMainBoxGeometry,18,4),
			makeInstance(mainBoxGeometry,55),
			makeInstance(rightMainBoxGeometry,92,-4), // lower
			makeInstance(rightMainBoxGeometry,92,4), // upper
			makeInstance(lowerBoxGeometry,55,-8,0,0,0,lowerBoxMaterial),
			makeInstance(upperBoxGeometry,55,7,0,0,0,upperBoxMaterial),

			makeInstance(endpointGeometry, -136, -10, -12, 0, - Math.PI / 4 * .5),
			makeInstance(endpointGeometry,136, -10, 12, Math.PI, Math.PI - Math.PI / 4 * .5),
		];

		{
			const loader = new THREE.TextureLoader();
			const texture = loader.load(
			'images/threeskybox.jpeg',
			() => {
				const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
				rt.fromEquirectangularTexture(renderer, texture);
				scene.background = rt.texture;
			});
		}

		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
			renderer.setSize(width, height, false);
			}
			return needResize;
		}

		function render(time) {
			time *= 0.001;

			if (resizeRendererToDisplaySize(renderer)) {
			const canvas = renderer.domElement;
			camera.aspect = canvas.clientWidth / canvas.clientHeight;
			camera.updateProjectionMatrix();
			}

			// wagons.forEach((cube, ndx) => {
			// const speed = 1 + ndx * .1;
			// const rot = time * speed;
			// cube.rotation.x = rot;
			// cube.rotation.y = rot;
			// });

			renderer.render(scene, camera);

			requestAnimationFrame(render);
		}

		requestAnimationFrame(render);
		}

		main();

		</script>
	</body>
</html>